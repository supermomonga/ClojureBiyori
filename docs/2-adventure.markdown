2日目 晴れた日は冒険しよう
===========================

1. アドベンチャーしよう
----------------------

　ぐたぐだと文法を解説するだけでは、退屈きわまりないものになってしまう。そこで、簡単なアドベンチャーゲームを作成してみよう。とはいえ、いきなり凄いものなんて出来るわけがない。だから、すごーく簡単なアドベンチャーゲームを作成してみよう。

　このアドベンチャーは、状況と行動の選択肢が出るという、すごいシンプルなゲームだ。古い言葉を使うなら、ゲームブックだ。

2. 貴方がClojureに伝えたいこと(read-line)
-----------------------------------------

　何はともあれ、ゲームにはプレイヤーの操作が必要だ。今回は、キーボードで、選択肢の番号を入力してもらう形にしようと思う。だから、手始めに、そこから始めよう。とはいっても、非常に簡単なもので、`read-line`関数を使えばいい。ありがちなサンプルだと、名前を入力して、それを返すという部分を作ってみよう、

```clojure
(println "貴方の名前はなんですか？")
(def your-name (read-line))
(println "こんにちは！" player-name)
```
　これで入力した文字列を、your-nameにセットすることができる。本当は、もっと上手いやりかたがあるけれども、今回は必要最低限でやっていこう。

3. 落としたのは、金の斧？銀の斧？(if, clojure.string/trim)
-------------------------------------

　今度は、有名な童話のシーンを再現してみよう。そのシーンとは、きこりが池に斧を落としたら、池の女神がやってくるシーンだ。

　複雑になりすぎないために、プレイヤーが行動を数字で選ばせるようにしよう。そこで、「3」だった場合だけ、金の斧と、銀の斧が手に入るようにしよう。

　さて、僕たちはいままで、値によって、表示する内容を変える、という方法をまだ知らなかった。この方法はある。もっとも簡単なのは`if`を使うことだ。

　`if`の役割は、値によって、あとでやるべきことを変えるということだ。僕たちの生活でも、「雨だったら家でだらだらしよう」とか考える。そういう風に、「○○だったら、××しよう」というのを表現できる。

```clojure
(println (if (= 2 (+ 1 1)) "正解" "間違い"))
```

　これを入力すると「正解」と出力されるはずだ。もし、ifの中の`2`を`3`にしたら、「間違い」と出力されるはずだ。どういうことなのかといえば、`if`のあとにある式が「真」か「偽」か、ということで結果が変わるようになっている。

　「真」と「偽」っていきなり言われると難しいけど、よくよく考えてみると簡単だ。

　私たちは、生活の中でいろんなものを比較する。例えば、あの店より、この店が安いとか、あるいは、このコロッケよりあのコロッケのほうが大きい、とかそういうことだ。当然、Clojureだって比較するのだ。

　たとえば、下の式を実行してみよう。

```clojure
(println (= 1 1)) ;; output: true
```

　この`true`というのは、前の式が「正しかった」ということをいう。逆に、`false`は間違いだった、ということをお知らせする。そして、`=`は、`AとBは一緒なの？`ということを表現している。

　ピンとこなければ、「1と1は同じだ！」といったら、君が嘘ついていることになるのかどうなのか、という風に考えてみるとよさそうだ。本当のことをいっているなら`true`、嘘をいっているなら`false`、それだけだ。`if`はこれを利用していて、正しいなら、3番目の値（式の結果）を、間違っているなら4番目（式の結果）を採用する。まとめると下の通りだ。

```
(if 比較する値(仮にxとする) xがtrueの場合に採用される値 xがfalseのときに採用される値)
```

```clojure
(println "「貴方が落としたのは、金の斧ですか？銀の斧ですか？」")
(println "1: 金の斧, 2: 銀の斧, 3: 普通の斧")
(def your-answer (read-line))
(if (= your-answer 3)
  (println "正直者には金の斧と銀の斧を与えましょう")
  (println "傲慢なものには、斧を返しません"))
```

　さて、これを実行して`3`を入れると、期待した通りの結果が返ってこないだろう。望むところとしては、"正直者には金の斧と銀の斧を与えましょう"と出てきて欲しいのだけれども、残念なことに"傲慢なものには、斧を返しません"と出る。それはそうで、文字列と数字は違うからだ。

```clojure
(= 3 "3") ;; => false
```

　ではどうするべきだろう？一つには素直に文字列を比較する、という方法がある。しかし、これにも少し罠がある。今回の場合、入力であった。例えば最後に空白が入ってたときのことを考えよう。

```clojure
(= "3" "3 ") ;; => false
```

　これは最初でも同じ事だ。

　この問題に関しては、次のように考えることができる。「僕たちは数字の文字列だけが欲しい。空白が入っているなら取り除いて欲しいんだ！」と。自作することだって出来るけど、clojureはちゃんと便利なものを用意してくれている。`clojure.string/trim`というものだ。ためしに、こいつを通過した`"   3   "`という文字列と、`"3"`を比較してみよう。

```clojure
(= "3" (clojure.string/trim "   3    ")) ;;true
```

　そう、trueになる！こいつは、前後の空白を取り除いてくれる関数なのだ。だから、こいつの動きがわかるように、次のように書いてみよう。

```clojure
;; output: = test =
(println (clojure.string/trim "     = test =    ")) 
```

　というわけで、文字列が取り出せた。

4. 道は2つ以上あるのだ(cond)
---------------------------

というわけで、下のように書き直すことができる。

```clojure
(println "「貴方が落としたのは、金の斧ですか？銀の斧ですか？」")
(println "1: 金の斧, 2: 銀の斧, 3: 普通の斧")
(def your-answer (clojure.string/trim (read-line)))
(if (= your-answer "3")
  (println "正直者には金の斧と銀の斧を与えましょう")
  (println "傲慢なものには、斧を返しません"))
```

　しかし、これもまだ問題がある。だって選択肢は1〜3のどれかだった筈だ。だけど、プレイヤーが間違えて`3#`みたいな入力をしたり、いじわるして`4`とか入力した場合でも、1と2を選んだことになってしまう！

　さて、これを`if`で無理やり実装すると、下のような汚いコードになる。

```clojure
(if (= your-answer "3")
  (println "正直者には金の斧と銀の斧を与えましょう")
  (if (= your-answer "2")
    (println "傲慢なものには、斧を返しません")
    (if (= your-answer "1")
      (println "傲慢なものには、斧を返しません")
      (println "あなた、ちゃんと答えてください！"))))
```

　これは、むりやり日本語に直すと次のようになるだろう。

```
もし、your-answerが"3"であるなら、 "正直者には金の斧と銀の斧を与えましょう"と出力する
違うなら、your-answerが"2"であるかどうかを調べ、そうなら"傲慢なものには、斧を返しません"と出力する
違うなら、your-answerが"1"であるかどうかを調べ、そうなら"傲慢なものには、斧を返しません"と出力する
違うなら、"あなた、ちゃんと答えてください！"と出力する
```

　なにが冗長なんだろう？それは簡単だ。「違うなら」というところだ。下のように書ければ、もっとすっきりする。
```
もし、your-answerが"3"であるなら、 "正直者には金の斧と銀の斧を与えましょう"と出力する
your-answerが"2"であるなら、"傲慢なものには、斧を返しません"と出力する
your-answerが"1"であるなら、"傲慢なものには、斧を返しません"と出力する
上記にあてはまらないなら、"あなた、ちゃんと答えてください！"と出力する
```

　`if`だと、このような複数の条件をとれない。そのためにうってつけのものがある。それが`cond`だ。`cond`は下のように使う。

```
(cond
  ここが真なら ここを返す
  ここが真なら ここを返す
  …)
```

　だから、上の条件式も、下のように書ける。

```clojure
(cond
  (= your-answer "3") (println "正直者には金の斧と銀の斧を与えましょう")
  (= your-answer "2") (println "傲慢なものには、斧を返しません")
  (= your-answer "1") (println "傲慢なものには、斧を返しません")
  true (println "あなた、ちゃんと答えてください！"))
```

> **Lisp散策** とはいえ、他のLispを触った人であるならば、上の式を疑問に思うかもしれない。
> 例えば、Common LispのようなLispであるならば、`(cond なんらかのリスト……)`であり、
> さらにいえば、その何らかのリストは、`(ここが真である場合 ここの式を返す)`という構造を
> 持っている。例えば、上の式は`(cond ((= your-answer "3") (print "正直者には金の斧と銀の斧を与えましょう")))`
> と書かなくてはならない。

　最後にtrueを持ってきたのは、必ず最後で引っかかるようにするためだけれども、`true`という文字列をつかうと、何を意図しているかわからない、という問題がある。普通、プログラミング言語なら、こういった条件式で「それ以外」というのを説明するために`else`というのを使う。そして、Clojureにも、ちゃんとそういう条件式がついている。

> **Lisp散策** しかし、貴方が他のLisp言語を触っているならば──例えばCommon Lispなど──、上の言い方はちょっと不当のようにも見えるだろう。というのは、Common Lispにおいては、基本的に`else`節を`t`と書くのが慣習のようになっているらしいからだ。例えば、`(cond ((= 1 2) (- 1 1)) (t (+ 1 1))`を入力した場合、`2`が返ってくるはずだ。

　上の式は、つまり

```clojure
(cond
  (= your-answer "3") (println "正直者には金の斧と銀の斧を与えましょう")
  (= your-answer "2") (println "傲慢なものには、斧を返しません")
  (= your-answer "1") (println "傲慢なものには、斧を返しません")
  :else (println "あなた、ちゃんと答えてください！"))
```

　と書ける。しかし、こいつも順番には気をつけなければならない。

```clojure
(cond
  :else (println "あなた、ちゃんと答えてください！")
  (= your-answer "3") (println "正直者には金の斧と銀の斧を与えましょう")
  (= your-answer "2") (println "傲慢なものには、斧を返しません")
  (= your-answer "1") (println "傲慢なものには、斧を返しません"))
```

　とかやっちゃうと、他のものを訪ねてはくれない。覚えておいて損がないのは、`cond`というのは最初に引っかかった式の、次にある式を採用するということだ。だから、よくあるパターンとして、どんな場合でも当てはまっちゃうような条件式を書いてしまって、そこで常に引っ掛かってしまうというような間違いをすることがある。これには注意しよう。

### 特殊フォームについて

　このトピックスは少し難しい概念がある。もしここで混乱した場合は、飛ばしてしまってよい。

　一日目において、関数に渡されるさい、その式が一度評価される話をした。しかし、それがはてまらない式も幾つかある。これらのことを`特殊フォーム`と呼ぶ。例えば、`if`や`cond`の場合、その評価自体を、必要になるまで置いておくことが出来る。

　そこで、簡単な例を書いてみる。100以下の、任意の数から100を、順番に出力するための関数を定義してみよう。ちなみに、類似問題が、『計算機プログラムの構造と解釈』に載っている(手元にある人は、1.6を参照すること)。

```clojure
(defn nth-print [n]
  (if (> n 99) (println n)
      (do (println n)
          (nth-print (+ n 1)))))
```

　さて、ここであなたが、この`if`を抽象化できる！と考えたとしよう。即ち

```clojure
(defn new-if [n limit then-case else-case]
  (if (> n limit) then-case else-case))
```

　という関数を定義し、下のように書き直す。

```clojure
(defn nth-print [n]
  (new-if n 100 n (nth-print (+ n 1))))
```

　ここで、`StackOverflow`というエラーが出てきた筈だ。これらの詳しい解説は再帰の日にとっておくとして、重要なのは、1日目で説明したように、引数に与えられる関数は、まず最初にそれが評価されてしまう。つまり、`new-if`に与えられた`nth-print`の結果をまず定めようとしてしまうので、永遠と処理が終わらなかったのだ!

　ここで、`特殊フォーム`と呼ばれる所以がわかると思う。`if`の場合、引数に式が与えられたとしても、必要になるまで、その評価を置いておくことにより、本来は「してはいけない」処理をあとまわしにすることができる。

## 5. つながる真偽の輪

　さて、もう一つ気になることがある。`"1"`も`"2"`も結果が一緒なんだから、これをまとめてしまうことは出来ないんだろうか。出来る。この場合、`and`と`or`を使う。`and`は「全てがtrueのときtrue」であり、「どれかがfalseがfalseのとき、false」であり、`or`は「どれかがtrueのときtrue」であり、「全てがfalseのとき、false」だ。どういうことかといえば、次の式を試してみるといい。

```clojure
(and true true) ;; true
(and true false) ;; false
(or true false) ;; true
(or false false) ;; false
```

　基本的には、この二つによって、「○と○が正しいとき」（あるいは、「×または×のどちらかが正しいとき」）を表現できる。もしこれらがわかりにくかったら、こう考えてもいいかもしれない。つまり、「andは一つでもfalseが見つかったら、全体がfalseであることが確定する」し、「orは一つでもtrueが見つかったら全体がtrueであることが確定する」と。なもんだから、

```clojure
(and true true true true true false true true true) ;; false
(or false false false false true false false false) ;; true
```

　となる。いくら頑張ったところで、決定されてしまうのは避けられない。

　さて、アドベンチャーゲームの話に戻ろう。問題は、`"1"か"2"が入力されたとき`というのを表現したい、ということだった。

```clojure
(or (= your-answer "2") (= your-answer "1"))
```

　このように表現すればいい。

```clojure
(println "「貴方が落としたのは、金の斧ですか？銀の斧ですか？」")
(println "1: 金の斧, 2: 銀の斧, 3: 普通の斧")
(def your-answer (clojure.string/trim (read-line)))
(cond
  (= your-answer "3") (println "正直者には金の斧と銀の斧を与えましょう")
  (or (= your-answer "2") (= your-answer "1")) (println "傲慢なものには、斧を返しません")
  :else (println "あなた、ちゃんと答えてください！"))
```

　しかし、このままだと、入力された瞬間に、アドベンチャーは終わってしまう。「ちゃんと答えてください」と言っているんだから、もう一度入力して欲しい筈だ。

## 6. 無限ループって怖いね

　そこで、もしかしたら、上のコードをなんどもなんどもコピーすればいいんじゃないか、と考えるかもしれない。ちょっとまってくれ、それはバカなことだ。もし三回コピペするとしても、三回ともミスったら、終わってしまう。プレイヤーは常に無限回間違う可能性があるわけだから、無限回間違えたら無限回聞かなきゃならない。

　そこで、まず最初に面倒くさくならないように、関数の中にこいつらを閉じ込めてしまおう。随時に実行するためには`do`を使う。正確には、こいつはいらないんだけど、親切のために置いておいた方が「あ、このあとは随時実行するものなんだ」ということがわかる。

```clojure
(defn scene-1 []
  (do
    (println "「貴方が落としたのは、金の斧ですか？銀の斧ですか？」")
    (println "1: 金の斧, 2: 銀の斧, 3: 普通の斧")
    (def your-answer (clojure.string/trim (read-line)))
    (cond
      (= your-answer "3") (println "正直者には金の斧と銀の斧を与えましょう")
      (or (= your-answer "2") (= your-answer "1")) (println "傲慢なものには、斧を返しません")
      :else (println "あなた、ちゃんと答えてください！"))))
(scene-1)
```

　さて、ポイントは「この間はループしてくださいね」と伝えることだ。このようなループを実現したければ、`loop`と`recur`というペアを使う。loopは、下のよような宣言として使える。

```clojure
(loop [シンボル 初期値] 実行する式)
```

　この構造は何処かで見たことがあるはずだ。そう、`defn`だ。実はこれと似ている。例えば、`loop`を使って1から100の数字を表示するようにしてみよう。

```clojure
(loop [x 1]
  (if (> x 100) (println "end")
                (do (println x) (recur (+ x 1))))
```

　ここで一つポイントなのは、`loop`が取る引数というのは、必ず初期値とペアになっているということだ。だから、奇数にするとエラーが出る。

```clojure
(loop [x y z] (println "error!"))

=>
IllegalArgumentException loop requires an even number of forms in binding vector in user:1  clojure.core/loop (core.clj:4135)
```

`even number`とは、要するに偶数の数をとれ！ということだ。偶数の数、ということは、要するにちゃーんとシンボルと初期値を対応させようね、ということである。

　さて、次に`recur`について説明しよう。例えば、上の`loop`についてはどうやら「xを0にセットせよ」というところから始まっている。そして、初期値というからには、当然のことながら「初期」だけであって、次からは変わる可能性があるということだ。その初期値を違う値にする段階、これこそが`recur`に他ならない。

　なんだか話が複雑になってきた。要するにこういう風に考えるといい。

```
(loop [x 0] なんらかの処理 (recur x))

loop [x] <=> recur x <- 対応している！

loop [x 0] -> recur (+ x 1) -> loop 1 -> recur (+ x 1) -> loop x ...  
```

　つまり、`recur`と`loop`は対応していて、`recur`に値が渡されると、次のloopのときにそれが使われるという形になる。

　しかし、`recur`を使う場合に気をつけないといけないことがある。`recur`は、その性質上、実行時の末尾において呼び出されないといけない。例えば、次のように書くとエラーになる。

```clojure
(loop [x 1]
  (do (if (= x 100) x (recur (+ x 1)))
      (println x)))
```

　すると、`Can only recur from tail position`というエラーメッセージが出てきて怒られたはずだ。詳しくは後にまわすけれども、これは`末尾再帰`、もうちょっと正確にいうと`末尾呼び出し`と関係がある。

　しかし、あくまでも**実行時の末尾**において呼び出すだけであり、構成上末尾にある必要はない。例えば`if`や`cond`を使った場合、見掛け上は最後でなくても、`recur`は使える。

```clojure
(loop [x 1]
  (if (< x 100) (recur (+ x 1)) x ))
```

　これはエラーにならずに100が返ってくることが確認できる。これは、`if`や`cond`が特殊なフォームである事情による。前にも書いた通り、`if`や`cond`の式は、必要になるまで呼び出されることはない。だから、**実質**、上の`recur`は末尾にあたると考えることが出来る。

　さて、これでループの作りかたを学んだ。つまり、`:else`の場合は、`loop`でひとまとまりにして、もう一度質問するようにすればよい。

```clojure
(defn scene-1 []
  (do
    (loop []
        (println "「貴方が落としたのは、金の斧ですか？銀の斧ですか？」")
        (println "1: 金の斧, 2: 銀の斧, 3: 普通の斧")
        (def your-answer (clojure.string/trim (read-line)))
        (cond
            (= your-answer "3") (println "正直者には金の斧と銀の斧を与えましょう")
            (or (= your-answer "2") (= your-answer "1")) (println "傲慢なものには、斧を返しません")
            :else (do (println "あなた、ちゃんと答えてください！") (recur))))))
```

　これで、プレイヤーがちゃんとした解答をするまで、延々と再帰し続けるようにすることが出来た。あとは`scene-2`、`scene-3`といったように、このアドベンチャーをどんどん拡張していけばよい。

終わり
------

　2日目はここで終わりにしたいと思う。これだけではアドベンチャーとはいいがたいかもしれない。しかし、僕は子供の頃に、同級生が、`if`を積み重ねて膨大なアドベンチャーゲームを作っていたことを、覚えている。

　もちろん、これはつたないプログラムかもしれない。しかし、それが楽しければ、そして楽しませることが出来るなら、立派なゲームだ！
