4日目 再帰ック道場
=================

　おそらく、最近のプログラム言語であるならば、「再帰」が出来る筈だ。「再帰」というのは、「ある関数が、自らの関数を呼び出すこと」だ。Clojureのような言語がパワフルである理由の一つに、再帰的なプログラムが瞬時に書けることが挙げられるだろう。とはいえ、急にそんなことを言われても「なにいってるんだこいつ」という感じにしかならない。なので、再帰について、この日は学ぶ。

1. Dungeon Crawler !!
---------------------

　そこで、今回は例題として、洞窟の中を検索するプログラムを作ろうと思う。洞窟は、部屋と通路がある。通路は一つ以上の通路があり、次の部屋に続いている。そして、行き止まりの部屋の何処かに、宝物が隠されている。ざっと地図にすると、こういう感じだ。

```
A -> B -> C
       -> D -> E -> H
            -> F
            -> G
```

　さて、この場合に、宝物が`H`と`F`にあったとして、そこまでの経路を出力したいとする。こういうときに、「再帰」というのはとても力を発揮する。

2. 始まりの洞窟
---------------

　とはいえ、何事も一ずつ積み重ねていくことが大切だ。従って、まず最初に単純な洞窟を考えてみよう。単純な洞窟とは、即ち

```
A -> B
```

　という一直線の洞窟だ。バカにしているかもしれないが、こういう単純なところから始めたいと思う。

　まず最初に、上の洞窟をリストで表現してみよう。この場合、一直線だから

```clojure
'(A B)
```

　として表現できる。これを利用しやすいように、`dungeon`に結びつけておく。

```clojure
(def dungeon '(A B))
```

　普通、Lispだと`car`と`cdr`という記号を使うが、Clojureは人間に優しく`first`と`next`を使う。実は`rest`もあるのだが、今回は`rest`は使わない。

> `rest`と`next`の違いが気になる人は、`(next '(will-return-nil))`といと、
> `(rest '(will-return-list))`を入力して比較してみるといいだろう。
> `next`の場合は、`nil`が帰ってきて、`rest`は`()`が返ってくるはずだ。

　さて、まず最初に探索の終了の定義を決める。上の、抽象化したダンジョンの場合、リストの行き止まりは、その先に要素が無いことだと言える。次の要素が取り出せない場合、その部屋の要素を返そう。そして、次が存在してるときは、次に進めるようにしてみよう。即ち、次のような関数が作れるはずだ。

```clojure
(defn tresure-hunt [dungeon]
  (if (nil? (next dungeon))
     (first dungeon)
     (tresure-hunt (next dungeon))))
```

　さて、これを定義して、次のように実行してみよう。

```clojure
(tresure-hunt dungeon) ;;B
```

　無事、行き止まりである`B`が帰ってきたが、しかしこれでは何をしているのかさっぱりわからない。なので、この関数の行動をトレースするために、上の関数を少し書き直してみよう。

```clojure
(defn tresure-hunt [dungeon]
  (if (nil? (next dungeon))
     (first dungeon)
     (do (println (first dungeon) 
         (tresure-hunt (next dungeon))))))
```

　とすると、`A B`と出力されたはずである。Clojureは、次のように「再帰」を実行していった、と考えることができる。

1. まず最初に、`next`の関数を'(A B)へ適応する
2. `next`で'(B)が取り出せたので、`tresure-hunt`関数に'(B)渡す
3. `next`の関数を'(B)を適応する
4. `next`で`nil`が返ってきたのでBを返す
5. 結果、`tresure-hunt`関数の結果は`B`となる

　とはいえ、これは単純にループして、最後の要素になるまで調べているのとかわらないだろう。いや、むしろこのような再帰は、むしろそのような愚直なループに比べれば、コストがかかる可能性が高い。だとすると、再帰はむしろそういうループの貧弱なバージョンだと言われる恐れがある。

3. 旅人の洞窟
-------------

　再帰はパワフルなものではなかったのか？実は著者が嘘をついているだけなのではないか？そこで、次に分岐した洞窟を検索してみよう。

```
A -> B -> C
       -> D -> E
```

　さて、これをリストに直してみる。このとき、分岐する場合は、新しいリストを作るようにしてみよう。つまり

```clojure
'(A B ((C) (D E)))
```

　とする。さて、これを`dungeon`に結びつけて、もう一度`tresure-hunt`してみよう。

```clojure
(def dungeon '(A B ((C) (D E))))
(tresure-hunt dungeon)
```

　さて、この結果は`((C) (D E))`になったはずだ。`tresure-hunt`は、どっちの通路に行けばいいかわからないからだ。

　もしかしたら、これを見たときに、愚直に`(C)`を調べて、次に`(D E)`を調べるようなことを考えたかもしれない。それでもいいんだけれど、再帰が再帰として強力にしている点として、いざとなったら自らを分裂させることができる点にある。

　そこで、とりあえずダンジョンを、二つの入り口があるものとしてセットしよう。

```clojure
(def dungeon '((C) (D E)))
```

　問題は、この二つの入り口をどのようにして調べるかだ。そこで、`map`を使ってみよう。

```clojure
(map tresure-hunt '((C) (D E))) ;; C E
```

　無事、行き止まりを取り出してくれる。さて、これを`tresure-hunt`関数にどのように取り入れるか、だ。

　そこで、リストの中身が全てリストである場合は、mapを発行し、全ての通路を調べるようにしてみてはどうだろうか

　全てが何らかの値であるかどうかを調べる場合、`every?`を使う。これは`filter`と同じく、第二引数に対して真偽を調べるための関数を取る。

```clojure
(defn tresure-hunt [dungeon]
  (cond
     (every? list? dungeon) (map tresure-hunt dungeon)
     (nil? (next dungeon)) (first dungeon)
     :else (tresure-hunt (next dungeon))))
```

　これで、ちゃんと上の簡略した分岐で値が取れるかを調べてみよう。

```clojure
(tresure-hunt '((C) (D E))) ;; C E
```

　OKだ。最後に、全体のマップで、ちゃんと全ての通路の行き止まりが出てくるかどうかを調べよう。

```clojure
(def dungeon '(A B ((C) (D E))))
(tresure-hunt dungeon) ;; ((C E))
```

　成功だ。
