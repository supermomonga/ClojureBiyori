3日目 明日のための家計簿
=======================

1. 家計簿をつけよう
-------------------

(準備中)

2. ちょっとした計算に
--------------------

　例えば、今月の収支が下のような感じだったとする。

```
収入    200,000
家賃    -60,000
光熱費   -7,000
通信代  -10,000
```

　素朴にやると、これを足したり引いたりする式を作ることになる。

```clojure
(+ (+ (+ 200000 -60000) -7000 -10000))
```

　とはいえ、これは冗長だ。実は、この`+`というヤツは、どれだけの数字が並んだとしても、一気に計算してくれる。だから
```clojure
(+ 200000
   -60000
    -7000
   -10000)
```

　とやったとしても、ちゃーんと結果を出してくれる。偉い！これで合計が出せる。だけど、今月どれくらい無駄遣いしたんだろう、といったときに

```clojure
(+ 200000
   -60000
    -7000
   -10000)

(+ -60000
    -7000
   -10000)
```

　と、同じものを計算するわけだけど、これは面倒くさい。もっと一括して扱うことが出来ないだろうか?

## 3. 世界はリストで満ち溢れている

　Clojureの強力なところは、一つのリストから、足したり引いたりして、いろんなデータを作れることにある。だから、収支が入り乱れたリストだったとしても、上手くやれば、収支を綺麗に分けることが可能になる。むしろ、**Lis**t **p**rocesser というくらいなんだから、こいつらの本拠地だ。

　実は、僕たちが弄っていた`()`で固められたやつらの正体というのは、リストなのだ。ただ単に最初にくる関数を使って評価されるというだけの話だ。

　単純なところから始めてみよう。そもそもリストとは何かという話だ。リストは、何らかの要素をあつめたものだ。だから

```clojure
'(esehara "Hungry" 100)
```

　とか、そういうものだ。しかし、リストで管理すると何が便利なんだろう?

　ここで、財布を想像してみよう。財布の中には1, 5, 5, 100, 500が入っている。この財布の中身をリストで表現するなら、下のようになる。

```clojure
'(1 5 5 100 500)
```

　さて、ここから10円以下の小銭を見つけ出して、それらを全部寄付にまわして、財布の中身を軽くしたいと考える。そこで、`filter`というのを使う。

```clojure
(defn donation? [coin] (< coin 10))
(filter donation? '(1 5 5 100 500)) ;; => (1 5 5)
```

　さて、無事コインが取り出せたのはいいのだけれども、始めてみたときには、面を喰らう。そこで、「高階関数」というものの存在を知る必要がある。

4. 上には上がいる
----------------

　「高階関数」とは、要するに「関数を扱う関数」のことを言う。そしてリストの操作と高階関数というのは、切っても切れない関係にある。とはいえ、「関数を扱う関数」といったってピンとこないだろう。

　一つずつ考えてみよう。例えば、ある商品を購入したときに、消費税込みの値段を計算するような関数を考える。消費税を5%と考えて、これは、任意の商品に`1.05`をかければいい。

```clojure
(defn tax [x] (* x 1.05))
(tax 100) ;; => 105
```

　で、それぞれの商品に適応することを考えよう。例えば牛乳一パック200円、ポテトチップス100円、あとついでだから玉子パック150円も買っていこう。それぞれの商品の税込値段は……えーと

```clojure
(tax 200)
(tax 100)
(tax 150)
```

　とはいえ、基本的にClojurenというのは面倒くさがりなタイプが多い。わざわざそれぞれの商品の値段に掛け算するなんて勤勉なことはしたくない。商品の値段リストと、それに対してどれだけ掛ければいいかわかってるのだから、そうしてくれと思う筈だ。そういう関数はある。`map`だ。

```clojure
(println (map tax '(200 100 150)))
```

　すると、それぞれの商品が1.05倍になったリストが取り出せた筈だ。

　恐らく、Clojureをやるにあたって、この部分がまず最初にひっかかるところだ。関数型言語と呼ばれるやつらが難しい理由の一つに、このように「一つ（か、それ以上の）要素に適応できるものを、リストに適応する」という操作がピンと来ないというらしい。

　たぶん、大切なのは、一気にリストを処理しようと思わないことだ。まず最初に、そのリストの一つをどういう風に処理したいか考えることが重要のように感じる。そして次に「それをリストの全体に適応すると?」と考えたらいい。

　そして、実は`filter`も似たようなことをやっている。`filter`の関数を`map`に置き換えてみよう。

```clojure
(defn donation? [coin] (< coin 10))
(map donation? '(1 5 5 100 500)) ;; => (true true true false false)
```

　本当はもうちょっと難しいけれど、ざっくりとした理解としては、`filter`は`true`のやつだけ、リストに拾ってくると考えたらいい。

5. そして時は動き出す (doall, dorun)
------------------------------------

6. 名付けるほどでもないつまらない奴
---------------------------------

　さて、高階関数はリストと仲がいい、といった。同様に高階関数は匿名関数とも仲がいい。匿名関数というのは、「手続きは記述するけど、その関数自体には名前が無い」という奴だ。例えば下のようなもの。

```clojure
((fn [x] (print x)) "Hello, Anonymous function!")
```

　さて、こいつは一つだけ作っても何のために存在するかわからない奴だが、高階関数とペアになると一気に力を発揮する。というのは、リストに対して、匿名関数で定義された手続きを一括して行えるからだ。例えば、上の`filter`関数について、匿名関数を使って同じことをやってみよう。匿名関数は`fn`を使う。

```clojure
(filter (fn [coin] (< coin 10)) '(1 5 5 100 500))
```

　別に、この識別に使った関数自体を定義したってかまわないが、別に他の場所で使うわけでもない処理を逐一、名前をつけるのは面倒くさい。だって、それぞれのリストに適応するのだって面倒くさい！って思うんだから、名前だって、他のところに使わないんだったら飛ばしてしまいたい。少なくともその場凌ぎみたいな名前をつけるよりは混乱が無くて済む。

　同様に、消費税の部分も書き換えてみよう。こんどは、もっと簡単に`#`をつかってみる。

```clojure
(println (map #(* 1.05 %) '(200 100 150)))
```

　匿名関数の中に匿名関数を作る、なんて用途が無いなら、`#`をつかうと、このようなすっきりとした形にすることができる。

7. 値段は何かの値段だ
---------------------

　とはいえ、普通、家計簿には値段だけで記述することはありえない。大抵、金額とともに、「それは何の金額だったのか」を並列して書くのが普通だろう。この項目の最初で述べたとおり

```
収入    200,000
家賃    -60,000
光熱費   -7,000
通信代  -10,000
```

　というように、「収入」とか「家賃」とか、そういう情報も場合によっては取り出したい筈だ。これらをただ単にリストとして表現することもできるが、Clojureは、もっと人間に優しい方法を持っている。それが`マップ`というやつだ。他のプログラミング言語を知っているなら、「連想配列」みたいなものだ、と考えればしっくりくるかもしれない。

　マップは、値とキーの二つの種類を取る。例えば、上の項目から「家賃」を、このマップというやつで表現してみよう。

```clojure
{:name "家賃" :price -60000}
```

　さて、こいつの使い方だけれども、とても簡単だ。使い方としては次のような形になる。

```clojure
({:name "家賃" :price -60000} :name) ;;家賃
```

　さて、こいつはどう使うと便利だろうか?

　まず最初に、上記の項目をこのマップ形式に直してみよう。ざっと、下のような形になるだろう。

```clojure
(def account
  '({:name "収入" :price 200000}
    {:name "家賃" :price -60000}
    {:name "光熱費" :price -7000}
    {:name "通信費" :price -10000}))
```

　そして、任意の一つのデータを表示する関数も定義してみよう。ざっとこんな感じだろう。

```
(defn print-account [account-one]
  (println
    (str (account-one :name) "   " (account-one :price))))
```

　さて、この関数を、`map`を使って、各項目を表示してみよう。

```
(dorun
  (map print-account account))
```

　そうすると、各項目が整理された状態で表示された筈だ。しかし、これだけだと利便性がよくわからない。さらに、この`account`のリストから、各項目を計算してみよう。この場合、下のような式が使える。

```
(apply + (doall
    (map (fn [account-one] (account-one :price)) account)))
```

　このように、`マップ`を使う理由というのは、あるデータに対してよみやすくなるのみならず、一つのデータを加工することで、様々な表現を可能にしてくれる点にある。そして、Clojureのような言語が、データそれ自体よりも、そのデータを如何に加工するかということに着目するのは、上記のメリットを重要視するからのように思う。