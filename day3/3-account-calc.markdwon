3日目 明日のための家計簿
=======================

1. 家計簿をつけよう
-------------------

(準備中)

2. ちょっとした計算に
--------------------

　例えば、今月の収支が下のような感じだったとする。

```
収入    200,000
家賃    -60,000
光熱費   -7,000
通信代  -10,000
```

　素朴にやると、これを足したり引いたりする式を作ることになる。

```clojure
(+ (+ (+ 200000 -60000) -7000 -10000))
```

　とはいえ、これは冗長だ。実は、この`+`というヤツは、どれだけの数字が並んだとしても、一気に計算してくれる。だから
```clojure
(+ 200000
   -60000
    -7000
   -10000)
```

　とやったとしても、ちゃーんと結果を出してくれる。偉い！これで合計が出せる。だけど、今月どれくらい無駄遣いしたんだろう、といったときに

```clojure
(+ 200000
   -60000
    -7000
   -10000)

(+ -60000
    -7000
   -10000)
```

　と、同じものを計算するわけだけど、これは面倒くさい。もっと一括して扱うことが出来ないだろうか?

## 3. 世界はリストで満ち溢れている

　Clojureの強力なところは、一つのリストから、足したり引いたりして、いろんなデータを作れることにある。だから、収支が入り乱れたリストだったとしても、上手くやれば、収支を綺麗に分けることが可能になる。むしろ、**Lis**t **p**rocesser というくらいなんだから、こいつらの本拠地だ。

　実は、僕たちが弄っていた`()`で固められたやつらの正体というのは、リストなのだ。ただ単に最初にくる関数を使って評価されるというだけの話だ。

　単純なところから始めてみよう。そもそもリストとは何かという話だ。リストは、何らかの要素をあつめたものだ。だから

```clojure
'(esehara "Hungry" 100)
```

　とか、そういうものだ。しかし、リストで管理すると何が便利なんだろう?

　ここで、財布を想像してみよう。財布の中には1, 5, 5, 100, 500が入っている。この財布の中身をリストで表現するなら、下のようになる。

```clojure
'(1 5 5 100 500)
```

　さて、ここから10円以下の小銭を見つけ出して、それらを全部寄付にまわして、財布の中身を軽くしたいと考える。そこで、`filter`というのを使う。

```clojure
(defn donation? [coin] (< coin 10))
(filter donation? '(1 5 5 100 500)) ;; => (1 5 5)
```

　さて、無事コインが取り出せたのはいいのだけれども、始めてみたときには、面を喰らう。そこで、「高階関数」というものの存在を知る必要がある。

4. 上には上がいる
----------------

　「高階関数」とは、要するに「関数を扱う関数」のことを言う。そしてリストの操作と高階関数というのは、切っても切れない関係にある。とはいえ、「関数を扱う関数」といったってピンとこないだろう。

　一つずつ考えてみよう。例えば、ある商品を購入したときに、消費税込みの値段を計算するような関数を考える。消費税を5%と考えて、これは、任意の商品に`1.05`をかければいい。

```clojure
(defn tax [x] (* x 1.05))
(tax 100) ;; => 105
```

　で、それぞれの商品に適応することを考えよう。例えば牛乳一パック200円、ポテトチップス100円、あとついでだから玉子パック150円も買っていこう。それぞれの商品の税込値段は……えーと

```clojure
(tax 200)
(tax 100)
(tax 150)
```

　とはいえ、基本的にClojurenというのは面倒くさがりなタイプが多い。わざわざそれぞれの商品の値段に掛け算するなんて勤勉なことはしたくない。商品の値段リストと、それに対してどれだけ掛ければいいかわかってるのだから、そうしてくれと思う筈だ。そういう関数はある。`map`だ。

```clojure
(println (map tax '(200 100 150)))
```

　すると、それぞれの商品が1.05倍になったリストが取り出せた筈だ。

　恐らく、Clojureをやるにあたって、この部分がまず最初にひっかかるところだ。関数型言語と呼ばれるやつらが難しい理由の一つに、このように「一つ（か、それ以上の）要素に適応できるものを、リストに適応する」という操作がピンと来ないというらしい。

　たぶん、大切なのは、一気にリストを処理しようと思わないことだ。まず最初に、そのリストの一つをどういう風に処理したいか考えることが重要のように感じる。そして次に「それをリストの全体に適応すると?」と考えたらいい。

　そして、実は`filter`も似たようなことをやっている。`filter`の関数を`map`に置き換えてみよう。

```clojure
(defn donation? [coin] (< coin 10))
(map donation? '(1 5 5 100 500)) ;; => (true true true false false)
```

　本当はもうちょっと難しいけれど、ざっくりとした理解としては、`filter`は`true`のやつだけ、リストに拾ってくると考えたらいい。

5. 名付けるほどでもないつまらない奴
---------------------------------

　さて、高階関数はリストと仲がいい、といった。同様に高階関数は匿名関数とも仲がいい。匿名関数というのは、「手続きは記述するけど、その関数自体には名前が無い」という奴だ。例えば下のようなもの。

```clojure
((fn [x] (print x)) "Hello, Anonymous function!")
```

　さて、こいつは一つだけ作っても何のために存在するかわからない奴だが、高階関数とペアになると一気に力を発揮する。というのは、リストに対して、匿名関数で定義された手続きを一括して行えるからだ。例えば、上の`filter`関数について、匿名関数を使って同じことをやってみよう。匿名関数は`fn`を使う。

```clojure
(filter (fn [coin] (< coin 10)) '(1 5 5 100 500))
```

　別に、この識別に使った関数自体を定義したってかまわないが、別に他の場所で使うわけでもない処理を逐一、名前をつけるのは面倒くさい。だって、それぞれのリストに適応するのだって面倒くさい！って思うんだから、名前だって、他のところに使わないんだったら飛ばしてしまいたい。少なくともその場凌ぎみたいな名前をつけるよりは混乱が無くて済む。

　同様に、消費税の部分も書き換えてみよう。こんどは、もっと簡単に`#`をつかってみる。

```clojure
(println (map #(* 1.05 %) '(200 100 150)))
```

　匿名関数の中に匿名関数を作る、なんて用途が無いなら、`#`をつかうと、このようなすっきりとした形にすることができる。

5. ベクターさんいらっしゃい
--------------------------

　とはいえ、他にもこういう風に扱えるデータ形式は存在している。ベクターだ。ベクターは`[]`という形で使用する。

```clojure
["foo" "bar"]
```
`'()`と`[]`の違いは、`[]`の場合、その中にある要素を一回評価してしまうのに対して、`'()`は評価自体を置いておくという違いがある。例えば

```
'((+ 1 2) (+ 1 3))
[(+ 1 2) (+ 1 3)]
```

　を比べてみればわかる。例えば、`'()`で、何も定義されていないシンボル`undefined-symbol`をかこってみよう。

```
'(undefined-symbol) ;;ok
[undefined-symbol] ;; Error !!
```

　となる。これらも使い分けると便利だ。

