１日目 S式の誘惑
================

　やあ、ようこそ。この文章を読んでいるということは、たぶん何らかの意味で、Clojureに興味を持っているからだろう。

　Clojureという言語は、一般的にはLispの方言の一つだと言われている。Lispを特徴付けているのは、S式と呼ばれている表現だ。とはいえ、急に「S式」とか言われても、「はて、どういうこっちゃ？」となるだろう。詳しく、そして厳密な定義はともかくとして、そのS式というやつに触れてみたいと思う。

1.0 なぜS式が重要なの？
----------------------

(準備中)

1.1 はじまりのClojure
---------------------

　まず最初は、プログラミングの慣習にのっとって、`Hello, Clojure!`を出力してみよう。

```clojure
(println "Hello, Clojure!")
```

　さて、これを実行すると、確かに画面に`Hello, Clojure!`と表示される。そして、このカッコで囲まれたものこそ、S式というヤツに他ならない。

　もう少し噛み砕いてみよう。S式というのは（Clojureの場合はそうだが)、下のような構造を取る。

```clojure
(何かしらの処理 処理するべきものの一群)
```

　つまり、上の`(println "Hello, Clojure!")`は、`"Hello, Clojure!"を一行で表示しろ`と読み替えることができる。他にも足し算をしたければ、したのようになる。

```clojure
(+ 1 2)
```

　これも同じように、`1と2を足せ！`という風に読み替えることができる。

　もちろん、このS式は一つだけであるならば、かなり非力なものである。しかし、組み合わせてみるとどうだろう？

```clojure
(println (+ 1 (+ 2 3)))
```

　これを実行したときに、目の前には6という文字が一行に表示されているはずだ。この処理を追いかけると、下のようになる。

```
(((2 と 3 を足せ) と 1を足せ）を 表示しろ！)
```

　とはいえ、このままだと正直なにをやっているのかわからない。そこで、一つ、ClojureにおけるS式についての決まりごとを書いておこう。

* ClojureにおけるS式は、それが実行されたときに、その実行されたあとの値になる。

　なんのことだ、と思うかもしれないけど、よく考えると当たり前のことなのだ。どういうことかというと、僕たちが`1 + 3`という式を計算した時、`4`という数字を期待する。でもって、ノートにこういう風に書く。

```
1 + 3 = 4
```

　このような小学生のさんすうノートみたいな記述だけど、馬鹿にはできない。これと同じようなことが、実は上でも起こっている。

```
(2 と 3 を足せ) = 5
((2 と 3 を足せ) と 1を足せ) = (5 と 1 を足せ) = 6 
(((2 と 3 を足せ) と 1を足せ）を 表示しろ！) = ((5 と 1 を足せ) を表示しろ) = (6を表示しろ)
```

　このように、S式はぱたぱたと読み替えられて、最後の命令まで届けられ、そして最終結果を出す。最終結果はとくに受けとる相手がなければ、捨てられる。

　Clojure(もしかしたら他のLisp?)において、`()`というのは「やれ！」ということだ。そして、やったあとは、その結果になる。とすると、「やれ！」という前の命令みたいなのがあるということにもなる。その通りだ。例えば、下のコマンドを入力してみよう。

```clojure
(println println)
```

　すると、したのような結果が出てくる。

```
#<core$println clojure.core$println@(ここは任意の文字列)>
```

　こいつが、「やれ！」という前の「命令」の実体になる。小難しいことを言うと、「関数オブジェクト」とか、その辺のものになるんだろうけど、おいておく。ポイントは、このような命令は、基本的には先頭に置かれて始めて、行動するってことだ。

　「基本的には」ということは、例外もあるということなんだけど、あとで説明したいと思う。

1.2 Do it your function!!
-------------------------

　さて、最初に見た「println」というのは、最初からある関数なので、「ビルドイン関数」と呼ばれる。とはいえ、これを組み合わせているだけでは辛い。きっと君のプログラミングは、地獄のような「カッコモンスター」のような見た目になるはずだ。

　だから、まず最初に関数の作り方を学ぶ必要がある。

　最初から用意されている命令ではなく、自分で命令を追加したい場合、`defn`というのを使う。例えば、任意の数を二倍にする命令を定義してみよう。これは下のように書ける。

```clojure
(defn mul-two [x] (* x 2))
(mul-two 2) ;; => 4
```

